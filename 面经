5. Longest Palindromic Substring


10. Regular Expression Matching


15. 3Sum


17. Letter Combinations of a Phone Number


22. Generate Parentheses


23. Merge k sorted lists


28. Implement strStr()


29. Divide Two Integers 
  * 不用“／”，“％”运算符实现division，说了可以用binary search
  

32. Longest Valid Parentheses


33. Search in Rotated Sorted Array


37. Sudoku Solver


38. Count and Say(变形)


39. Combination Sum


42. Trapping Rain Water
407. Trapping Rain Water II


43. Multiply Strings


49. Group Anagrams - use counting sort


53. Maximum Subarray


56. Merge Intervals
Variant: 一串start time － end time，格式是Apr 2010 － Mar 2011这种，要求计算出这些时间的总跨度，重叠的跨度不重复计算。
举例：["Apr 2010 - Dec 2010", "Aug 2010 - Dec 2010", "Jan 2011 - Mar 2011"]


57. Insert Interval


62. Unique Paths I/II


65. Valid Number


71. Simplify Path


75. Sort Colors
  * 给三个funtions: is_low(), is_mid(), is_high(). 让给一个数组排序, low的放在最前面, mid的放在中间, high的放在最后面.
  * Color sort: think about when there are K colors


79. Word Search
  * 输出所有 root - leaf 的路径，递归做完了让迭代。
  * Iterative? BFS?
  
  
78. Subsets
90. Subsets II


91. Decode Ways


98. Validate Binary Search Tree


102. Binary Tree Level Order Traversal


111. Minimum Depth of Binary Tree


114. Flatten Binary Tree to Linked List
  * Linked list needs to be formed as a cycle
  

117. Populating Next Right Pointers in Each Node I / II
  * salbring tree，不过没有next指针， 你要用原来的left，right指针
  * Level BFS
  

121-123, 188, 309 Best Time to Buy and Sell Stock, (I and II)
  * buy and sell stock，每天可以买一股，也可以都卖了，或者不买不卖。
  * Find maximum, buy from earlier days, and sell on that day.
  

125. Valid Palindrome


128. Longest Consecutive Sequence


133. Clone Graph


138. Copy List with Random Pointer


139. Word Break I/II


151. Reverse Words in a String


152. Maximum Product Subarray


158. Read N Characters Given Read4 II - Call multiple times


161. One Edit Distance


173. BST iterator
  * Iterator for a list of BSTs (heap contain each BST’s iterator)
  * BST to increasing array (Recursive, iterative)
  

191. Number of 1 Bits


198. House Robber


200. Number of Islands


206. Reverse Linked List


209. Minimum Size Subarray Sum
  * Map store previous values ( O(N) )
  * 把第一题extend到2D。给一个matrix, all elements are positive，问有没有个sub rectangle加起来和等于target。return true/false。
  * Lz听到题目有点懵，认真调整心态，解决之。先写了个cumulative sum。把所有从0,0 到i,j的和算在新的matrix的i,j上。方便之后算head到tail的sub rectangle的和。这一步O(n^2)


211. Add and Search Word (add and search word with wild card)


214. Shortest Palindrome


215. Kth Largest Element in an Array (Average O(n) Worst case O(n^2))


218. The Skyline Problem (hard)


221. Maximal square


224. Basic Calculator


238. Product of Array Except Self


239. Sliding Window Maximum


253. Meeting Rooms II (求最多interval的时间点，返回任意一个就行)


261. Graph Valid Tree (any connected graph without simple cycles is a tree).


273. Integer to English Words


277. Find the Celebrity


278. First Bad Version


282. Expression Add Operators


283. Move Zeroes - Minimizing “writes”
  * moving all the nonzeros to the front of a list


285. Inorder Successor in BST


297. Serialize and Deserialize Binary Tree


301. Remove Invalid Parentheses (hard)
Maintain counter and go from left to right, remove when necessary, then counter must be > 0, then remove “(“ from right hand side


310. Minimum Height Trees


311. Sparse Matrix Multiplication (sparse vector dot multiplication)
    这道题我当时并没有准备到，但是正因为如此，我认为我跟面试官的交流给我加分了不少。

    面试官首先问我每个vector很大，并不能在内存中存下，该怎么办，我说只需要存下非零的元素和他们的下标就行，
    然后询问面试官是否可以用预处理后的这两个vector非零元素的index和value作为输入，面试官同意后快速写完O(M*N)的代码，M和N分别是两个vector的长度。

    面试官说这两个输入如果是根据下标排序好的话应该怎么办，我说可以遍历长度较短的那一个，然后用二分搜索的方法在另一个vector中找index相同的元素，
    相乘加入到结果中，这样的话复杂度就是O(M*logN)。

    这时，面试官又问是否可以同时利用两个输入都是排序好这一个特性，我在这个地方有点卡住，但是在白板上写出一个test case，试着用可视化的方法帮助我来进行思考，
    同时面试官给了一些提醒，最后写出了O(M + N)的双指针方法

    然后问如果有一个向量比另一个长很多怎么办，遍历短的，对长的二分查找。

    两个vector相乘


314. Binary Tree Vertical Order Traversal (Print a binary tree by columns top to bottom)


334. Increasing Triplet Subsequence (一个数组内要是存在至少三个升序的数（array[x] < array[y] < array[z], x < y < z）就返回true)


341. Flatten Nested List Iterator


350. Intersection of Two Arrays II
  * Sort, then find duplicates


398. Random Pick Index


543. Diameter of Binary Tree


545. Boundary of Binary Tree 顺时针的print binary tree boundary, 就是从根开始，先打右边界，再打叶子，最后打左边界。







******************************************************************************************************************************


1. 给2D平面上的N个点，求离原点最近的K个点
   Given some points in two dimensional space, find k points out of all points which are nearest to origin(0,0)



2. Task那道题，很多面经都提到过。就是比如给你一串task，再给一个cooldown，执行每个task需要时间1，两个相同task之间必须至少相距cooldown的时间，问执行所有task总共需要多少时间。
比如执行如下task：12323，假设cooldown是3。总共需要的时间应该是 1 2 3 _ _ 2 3，也就是7个单位的时间。再比如 1242353，假设cool down是4，那总共时间就是 
1 2 4 _ _ _ 2 3 5 _ _ _ 3，也就是13个单位的时间基于1，给出最优的排列，使得字符串最短。


# Tasks: 1, 1, 2, 1
# Recovery interva (cooldown): 2
# Output: 7  (order is 1 _ _ 1 2 _ 1)

# Example 2
# Tasks: 1, 2, 3, 1, 2, 3
# Recovery interval (cooldown): 3
# Output: 7  (order is 1 2 3 _ 1 2 3). more info on 1point3acres.com

# Example 3
# Tasks: 1, 2, 3 ,4, 5, 6, 2, 4, 6, 1, 2, 4. 1point3acres.com/bbs
# Recovery interval (cooldown): 6
# Output: 18  (1 2 3 4 5 6 _ _ 2 _ 4 _ 6 1 _ 2 _ 4)
*/

def taskSchedule(tasks, cooldown):
    result = ''
    index_map = {}
    for t in tasks:
        while index_map.has_key(t) and index_map[t] + cooldown > len(result):
            result += '_'

        result += str(t)
        index_map[t] = len(result)


    return result

t1 = [1, 1, 2, 1]
k1 = 2
print taskSchedule(t1, k1)

t2 = [1, 2, 3, 1, 2, 3]
k2 = 3
print taskSchedule(t2, k2)

t3 = [1, 2, 3 ,4, 5, 6, 2, 4, 6, 1, 2, 4]
k3 = 6
print taskSchedule(t3, k3)
  
  
  
  


3. 给一个tree，每个node 有很多children，找到所有最深的nodes 的common ancestor, 比如只有一个点最深，那返回他自己。

         1
        /  \
       2    3 
           /  \
          4    5
   比如这个例子，最深的节点是4 和 5. 他们的公共节点是3。所以答案是3。最深的节点可以只有一个，那就返回节点本身。
   
   * Similar to 236. Lowest Common Ancestor of a Binary Tree 
   * follow up 指向母点的指针 

   跟二叉树一样，不用先求深度，可以one pass。   
   对于root，每个孩子遍历一遍，如果孩子深度大于max，就更新max，然后返回的是孩子，如果等于max，说明有多个孩子深度一样，那么返回root

        class Result {
                int depth;
                TreeNode node;
        }
        

        public Result deepestRoot(TreeNode root) {
                if (root == null) {
                        return new Result(0, null);
                }

                Result left = deepestRoot(root.left);
                Result right = deepestRoot(root.right);

                Result ret = new Result();
                if (left.depth == right.depth) {. 1point3acres.com/bbs
                        //两边一样深,root 是公共
                        ret.node = root;
                        ret.depth = left.depth + 1;
                } else if (left.depth > right.depth) {
                        //左边深,
                        ret.node = left.node;
                        ret.depth = left.depth + 1;
                } else {
                        ret.node = right.node;
                        ret.depth = right.depth + 1;
                }
                return ret;
        }






4. 几何算法问题。如果给你一堆的矩形， 求重合矩形重合最多的坐标位置。我上过一个算法课，大概思路就是做一个二维的meeting room II



5. two sum + three sum + follow up



6. binary tree转换成doubly linked list
  * And revert it back (reverted to balanced tree): 109. Convert Sorted List to Binary Search Tree
  


7. 给一个字典包括很多字符串(e.g., abcd, dhfyf)，然后给定一个字符串查看字典中是否包含这个字符串。字符串中可能包括*，*可以匹配任何字符。我用的Trie。



8. 自然string comparator。不知道的搜下。就是string 比较的时候考虑里面数字的大小，比如 abc9 < abc123 abc > ab9  因为char比digit重要。



9. We're given a sorted array of integers: [-3, -1, 0, 1, 2]. We want to generate a sorted array of their squares: [0, 1, 1, 4, 9]



10. list of sorted integer arrays，要求找所有的数的median. e.g. [1,3,6,7,9], [2,4,8], [5], return 5



11. linked list 反序输出 - 1) reverse the list; 2) recursion



12. flatten nested array



13. Prettify JSON:  输入[1,2,3, {"id": 1, "name": "wang", "tag":[1,"home",2], "price":234}]



14. Smallest subarray with sum greater than a given value



15. Min Queue, 跟Min Stack类似， 实现一个Queue， 然后O（1）复杂度获得这个Queue里最小的元素。



16. interval [startTime, stoptime)   ----integral  time stamps
给这样的一串区间 I1, I2......In, 找出 一个 time stamp  出现在interval的次数最多。
startTime <= t< stopTime 代表这个数在区间里面出现过。
example：  [1,3),  [2, 7),   [4,  8),   [5, 9)
5和6各出现了三次， 所以答案返回5，6。  (Hard)



17. shortest continuous substring with all characters in input
  * 76. Minimum Window Substring



18. 合并邮件列表
Given 1 million email list:
list 1: a@a.com, b@b.com
list 2: b@b.com, c@c.com
list 3: e@e.com
list 4: a@a.com
...
Combine lists with identical emails, and output tuples:
(list 1, list 2, list 4) (a@a.com, b@b.com, c@c.com)
(list 3) (e@e.com)



19. 一个完全树。node有parent指针。
每个node的值为 0或 1, 每个parent的值为两个子node的 “and” 结果
现在把一个leaf翻牌子（0变1或者1变0）. visit 1point3acres.com for more.
把树修正一遍




20. 找两个字符串中长度为N以上的共同子串
  * 找出两个给出两个string, leetcode, codyabc和一个数字k = 3,问两个string里面存不存在连续的common substring大于等于k.
    比如这个例子，两个string都有cod,所以返回true。楼主用dp建了一个m*n的table秒了，然后写test case,发现有个小corner case,改了,pass
  * Longest common substring



21. 给定一个数列，比如1234，将它match到字母上，1是A，2是B等等，那么1234可以是 ABCD
但是还可以是12是L，所以1234也可以写作 LCD 或者 AWD



22. 给出N个序列，比如2个序列A,B,没个序列包含若干的区间，比如
A: [1,5], [10,14], [16,18]
B: [2,6], [8,10], [11,20]
Merge them all:  [1,6], [8, 20].



23. balance parentheses in a string
例子：
"(a)()" -> "(a)()"
"((bc)" -> "(bc)"
")))a((" -> "a"
"(a(b)" ->"(ab)" or "a(b)"
Note: balance的意思就是把原来string里unpaired的括号变成paired的形式。
如果有多个可能的结果， 比如上述最后一种情况，我们就只需要输出一个对的结果即可，所以这点简化了题目的难度。
感受： 遍历string， 用一个stack存储每个open parenthesis的index，也就是'('的index, 每当遇到closed parenthesis就执行一次pop操作。
注意两种unbalanced的情况：
1. 出现多余的')':
    对应情况就是stack为空，但遇到了一个')'。
2. 出现多余的'(':
    对应情况就是遍历结束，stack未空



24. get binary tree's next node in inorder
class Node {Node left, Node right, Node parent}
Node getNext (Node current) {}



25. Given a list of number, there is only one peak or one drop. Find the maximum drop.
Exps:
1 -> 2 -> 3 -> 9 -> 3 -> 0 = 9;
10 -> 4 -> 3 -> 8 = 7 ;



26. Longest Arithmetic Progression



27.implement circular array
  * Circular buffer


28. Check big/small endian



29. 给一个linkedlist，里面的element都排序好了，但是是一个blackbox，有三个function可以调用。
pop()随机pop出最前面或最后面的element，
peek()随机偷看最前面或最后面的element，
isEmpty()回传linkedlist是不是空了。
问设计一个资料结构，list或是array都可以，把linkedlist里面所有的element都拿出来，并保持他们的排序。followup是如果不能用peek()该怎么做。
My thinking: if I got element A, and next element B is smaller than A, then A is from the tail of the list; 
otherwise, A is from the head of the list.



30.
第一题：binary tree，给定一个value，return bin tree里面下一个比value大的值
第二题：binary tree的node加一个ptr next，point到inorder traversal的下一个node，比上一个简单



31. print max depth path of a binary tree



32. Erase duplicate in an unsorted array



33. 给定N个2D坐标（可以设想为餐厅的位置），要求输入任意坐标，可以返回方圆d距离内的所有餐厅



34. find longest arithmetic sequence in an unsorted array



35. find number of palindrom in a string



36. partition array sum
    给定一个array 返回一个partition point可以返回该index左边的和和右边的和一样，没有就返回-1，这个要求时间空间最优
    
    
    
37.给一个string， 判断是不是数字



38.给一个2d matrix，每个里面值要么是1要么是0， 假如出现1，后面的数都是1.
找出最左边是1的列
[[0, 0, 1, 1, 1],
[0, 1, 1, 1, 1],
[0, 0, 1, 1, 1],
[0, 0, 0, 0, 0]]

从右上角开找就好吧 碰到1往左走 碰到0 往下走

int left = matrix[0].length;
for (int i = 0; i < matrix.length; i++) . 涓€浜�-涓夊垎-鍦帮紝鐙鍙戝竷
    for (int j = 0; j < left; j++) {
          if (matrix[i][j] == 1) {. from: 1point3acres.com/bbs 
                 left = j;
                 break;
          }
    }

return left;
}



38. 给两个array找common elements，一个1M长，一个1K长
    就是求集合的交集。。。 你可以二分，也可以两个指针互相追赶。。这个情况下，明显是从短的数组里枚举每个数，然后二分长的数组.. (当然一开始要排序)..
    排序的话用时间 n=1M, m=1k     nlgn+mlgm, 找用时间mlgN..



39. 给你一个数字比如111112222333112，返回每个数字出现的个数和数字本身，这个例子的返回为5142332112. 写完之后问这个返回的result，最短多长，最长多长。



40. 给你一个数字由1-9组成，给你一个target value，可以在数字中间加 + 或者 -, 问你有多少种组合可以得到target value。同时有一个eval method，
    把表达式传进去，返回计算结果。类似于lc282,484的mix。这里和282相比不需要做乘法，并且符号可以加在第一数的前面，这里和484一样。
    但是和484不同的是数字并不一定是一位，可以是多位组成，这里和282一样。写完后，让跑test,最后问时间复杂度。




41. Given 2-d matrix with 1s and 0s, where 1 represents obstacle and 0 represents road,  find a path from upper left conner to the bottom right conner. 



42. Recommend K friends with most mutual friends.


43, Given an array will have either a valley or a mountain, only one, not one of each, find out the index of the valley or peak element
And with one more assumption: array[i - 1] = array[i] + 1 or array[i - 1] = array[i] - 1.
Example 1: [1,2,3,4,3,2,1] --> return 3
Example 2: [6,5,4,3,2,3,4] --> return 4


使用那个assumption可以达到O(1) 复杂度：首先判断isUp or not，仅以isUp为例, 假设A[x] 是最高点，则有：
A[x] - A[i] = x - i
A[x] - A[j] = j - x

由此可以解出 x = 1/ 2 * (A[j] - A[i] + i + j)，isdown同理可求

public int findPeak(int [] A){
            boolean isUp = (A[1] > A[0]) ? true : false;
            if (isUp){
                return (A[A.length - 1] - A[0] + A.length - 1) / 2;.鏈枃鍘熷垱鑷�1point3acres璁哄潧
            } else {
                return (A[0] - A[A.length - 1] + A.length - 1) / 2;. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
            }

        }

Ref: http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=274834&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311








https://instant.1point3acres.com/thread/197099
http://www.1point3acres.com/bbs/thread-203983-1-1.html
