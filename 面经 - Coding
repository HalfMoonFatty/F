001. BT LCA with deepest leaf
   Follow-up:
   1. Recursive and Iterative (指向母点的指针)
   2. Each node has multiple children
   * Similar to 236. Lowest Common Ancestor of a Binary Tree 
    
[X] 002. Prettify JSON:  输入[1,2,3, {"id": 1, "name": "wang", "tag":[1,"home",2], "price":234}]

003. Flatten Nested Array

004. Flatten Nested Linked List

005. Binary Tree Level Order Traversal

006. Sort color
     Follow-up: Sort K-color

007. Merge 2 array in-place

008. Balance Parentheses in a string

009. 给2D平面上的N个点，求离原点最近的K个点
     Given some points in two dimensional space, find k points out of all points which are nearest to origin(0,0)

010. Decode Ways
     Follow-up: Output the result of all decode string

[X] 011.  一个骑士在一个无限大的有障碍的国际象棋棋盘. calculate the shortest path to some target.
        Follow-up: how to optimize: A*, pruning.
        Edge case: how to end the program? what kinds of target is unreachable and how to avoid?

012. Longest consecutive sequence

* 013. Reconstruct BST From Pre-order Sequence

014. Remove Target Char from a Source String

015. Subarray Equals K

016. Implement strStr()

017. Minimum Depth of Binary Tree

018. Subarray Sum Equals K

019. 3 Sums

020. Insert Node to Sorted LinkedList

021. Read N Characters Given Read4K / Read N Characters Given Read4K II - Call multiple times

022. Best Time to Buy and Sell Stock I-IV

023. Binary Tree print path to leaf (BT path leaf)

024. Binary Tree Vertical Order Traversal

025. Check Consecutive Subarray Duplicate Numbers

* 026. Remove Invalid Parentheses

* 027. Permutation in String

028. First Bad Version

029. Valid Palindrome

030. Dot Product

* 031. Find longest arithmetic subsequence in an unsorted array (Longest Arithmetic Progression)

032. longest PATH(could be the path from leaf to leaf) in binary tree(BT longest path)

033. Word Search I + II

034. Product of the Array

035. Combination Sum I-IV

036. Binary Tree In Order Traversal with Parent Node

037. Regular Expression Matching

[X] 038. Data Stream as Disjoint Intervals (LC 352)

[X] 039. Task Schedule 

040. Kth Largest Element in an Array

041. Reverse Print Linked List (Recursive/Iterative) / Reverse Linked List

042. 









******************************************************************************************************************************

4. 几何算法问题。如果给你一堆的矩形， 求重合矩形重合最多的坐标位置。我上过一个算法课，大概思路就是做一个二维的meeting room II



5. two sum + three sum + follow up (allows duplicates and each number could be reused)
Three sum with duplicate, pirnt all indexes, for example: 
0 2 -2 -2 
(0)(1)(2)(3) 
print (0, 1, 2) (0, 1, 3) 
can you do it use n^2 (or less) time complexity with as less space as possible? 
public List<List<Integer>> threeSum(int[] nums) {}



6. binary tree转换成doubly linked list
  * And revert it back (reverted to balanced tree): 109. Convert Sorted List to Binary Search Tree
  


7. 给一个字典包括很多字符串(e.g., abcd, dhfyf)，然后给定一个字符串查看字典中是否包含这个字符串。字符串中可能包括*，*可以匹配任何字符。我用的Trie。



8. 自然string comparator。不知道的搜下。就是string 比较的时候考虑里面数字的大小，比如 abc9 < abc123 abc > ab9  因为char比digit重要。



9. We're given a sorted array of integers: [-3, -1, 0, 1, 2]. We want to generate a sorted array of their squares: [0, 1, 1, 4, 9]



10. list of sorted integer arrays，要求找所有的数的median. e.g. [1,3,6,7,9], [2,4,8], [5], return 5



14. Smallest subarray with sum greater than a given value



15. Min Queue, 跟Min Stack类似， 实现一个Queue， 然后O（1）复杂度获得这个Queue里最小的元素。



16. interval [startTime, stoptime)   ----integral  time stamps
给这样的一串区间 I1, I2......In, 找出 一个 time stamp  出现在interval的次数最多。
startTime <= t< stopTime 代表这个数在区间里面出现过。
example：  [1,3),  [2, 7),   [4,  8),   [5, 9)
5和6各出现了三次， 所以答案返回5，6。  (Hard)



17. shortest continuous substring with all characters in input
  * 76. Minimum Window Substring



18. 合并邮件列表 
Given some email ids, and a similarity function which says whether two email ids are similar, determine all the sets of email ids that are similar to each other.

Given 1 million email list:
list 1: a@a.com, b@b.com
list 2: b@b.com, c@c.com
list 3: e@e.com
list 4: a@a.com
...
Combine lists with identical emails, and output tuples:
(list 1, list 2, list 4) (a@a.com, b@b.com, c@c.com)
(list 3) (e@e.com)



19. 一个完全树。node有parent指针。
每个node的值为 0或 1, 每个parent的值为两个子node的 “and” 结果
现在把一个leaf翻牌子（0变1或者1变0）把树修正一遍




20. 找两个字符串中长度为N以上的共同子串
  * 找出两个给出两个string, leetcode, codyabc和一个数字k = 3,问两个string里面存不存在连续的common substring大于等于k.
    比如这个例子，两个string都有cod,所以返回true。楼主用dp建了一个m*n的table秒了，然后写test case,发现有个小corner case,改了,pass
  * Longest common substring




22. 给出N个序列，比如2个序列A,B,没个序列包含若干的区间，比如
A: [1,5], [10,14], [16,18]
B: [2,6], [8,10], [11,20]
Merge them all:  [1,6], [8, 20].




24. get binary tree's next node in inorder
class Node {Node left, Node right, Node parent}
Node getNext (Node current) {}




25. Given a list of number, there is only one peak or one drop. Find the maximum drop.
Exps:
1 -> 2 -> 3 -> 9 -> 3 -> 0 = 9;
10 -> 4 -> 3 -> 8 = 7 ;




26. Longest Arithmetic Progression




27.implement circular array
  * implement circular buffer with read & write functions




28. Check big/small endian




29. 给一个linkedlist，里面的element都排序好了，但是是一个blackbox，有三个function可以调用。
pop()随机pop出最前面或最后面的element，
peek()随机偷看最前面或最后面的element，
isEmpty()回传linkedlist是不是空了。
问设计一个资料结构，list或是array都可以，把linkedlist里面所有的element都拿出来，并保持他们的排序。followup是如果不能用peek()该怎么做。
My thinking: if I got element A, and next element B is smaller than A, then A is from the tail of the list; 
otherwise, A is from the head of the list.




30.
第一题：binary tree，给定一个value，return bin tree里面下一个比value大的值
第二题：binary tree的node加一个ptr next，point到inorder traversal的下一个node，比上一个简单




31. print max depth path of a binary tree




32. Erase duplicate in an unsorted array




33. 给定N个2D坐标（可以设想为餐厅的位置），要求输入任意坐标，可以返回方圆d距离内的所有餐厅




34. find longest arithmetic sequence in an unsorted array




35. find number of palindrom in a string




36. partition array sum
    给定一个array 返回一个partition point可以返回该index左边的和和右边的和一样，没有就返回-1，这个要求时间空间最优
    Given an array of integers greater than zero, find if it is possible to split it in two (without reordering the elements), 
    such that the sum of the two resulting arrays is the same. Print the resulting arrays.


    
    
37.给一个string， 判断是不是数字




38.给一个2d matrix，每个里面值要么是1要么是0， 假如出现1，后面的数都是1.
找出最左边是1的列
[[0, 0, 1, 1, 1],
[0, 1, 1, 1, 1],
[0, 0, 1, 1, 1],
[0, 0, 0, 0, 0]]

从右上角开找就好吧 碰到1往左走 碰到0 往下走

int left = matrix[0].length;
for (int i = 0; i < matrix.length; i++) . 涓€浜�-涓夊垎-鍦帮紝鐙鍙戝竷
    for (int j = 0; j < left; j++) {
          if (matrix[i][j] == 1) {. from: 1point3acres.com/bbs 
                 left = j;
                 break;
          }
    }

return left;
}




38. 给两个array找common elements，一个1M长，一个1K长
    就是求集合的交集。。。 你可以二分，也可以两个指针互相追赶。。这个情况下，明显是从短的数组里枚举每个数，然后二分长的数组.. (当然一开始要排序)..
    排序的话用时间 n=1M, m=1k     nlgn+mlgm, 找用时间mlgN..




39. 给你一个数字比如111112222333112，返回每个数字出现的个数和数字本身，这个例子的返回为5142332112. 写完之后问这个返回的result，最短多长，最长多长。




40. 给你一个数字由1-9组成，给你一个target value，可以在数字中间加 + 或者 -, 问你有多少种组合可以得到target value。同时有一个eval method，
    把表达式传进去，返回计算结果。类似于lc282,484的mix。这里和282相比不需要做乘法，并且符号可以加在第一数的前面，这里和484一样。
    但是和484不同的是数字并不一定是一位，可以是多位组成，这里和282一样。写完后，让跑test,最后问时间复杂度。




41. Given 2-d matrix with 1s and 0s, where 1 represents obstacle and 0 represents road,  find a path from upper left conner to the bottom right conner. 



42. Recommend K friends with most mutual friends.



43. Given an array will have either a valley or a mountain, only one, not one of each, find out the index of the valley or peak element
And with one more assumption: array[i - 1] = array[i] + 1 or array[i - 1] = array[i] - 1.
Example 1: [1,2,3,4,3,2,1] --> return 3
Example 2: [6,5,4,3,2,3,4] --> return 4


使用那个assumption可以达到O(1) 复杂度：首先判断isUp or not，仅以isUp为例, 假设A[x] 是最高点，则有：
A[x] - A[i] = x - i
A[x] - A[j] = j - x

由此可以解出 x = 1/ 2 * (A[j] - A[i] + i + j)，isdown同理可求

public int findPeak(int [] A){
            boolean isUp = (A[1] > A[0]) ? true : false;
            if (isUp){
                return (A[A.length - 1] - A[0] + A.length - 1) / 2;
            } else {
                return (A[0] - A[A.length - 1] + A.length - 1) / 2;
            }

        }

Ref: http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=274834&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311




44. Given a set of candidate numbers (C) (with duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
The same repeated number may be chosen from C unlimited number of times.




45. 给定一个数组, 已经sort好, 里面有大量重复的数, 输出每个数和这个数出现的次数. 
输入[1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3]这样一个数组，返回{1, 4}, {2, 7}, {3, 10}
其实就是不同的数字要你计数，但是要求优于O(n)

先说扫一遍, 用hashmap计数, 问time complexity说是O(n), 不够好, 怎么快点儿, 答binary search. 

lz当时第一反应是binary search 找上下界，然后小哥问我worst case，我说O(nlgn)，小哥说对啊，我要优于O(n)。 

每次比较start point 和start point + 2^n位置上的数，假如一样就continue，不一样就在区间里面binary search找上界，这样的话worstcase O(n)

假设没有重复的数， [1,2,3,4,5] 每次都找 2^(n-1)  == 2^0 ==1 , 相当于依次 找1 找2 找3 找4 找5 发现都是出现一次， 遍历一遍， O(n). 

如果有大量重复， 【1，1，1，1，2，2，2，3】，对于1， 找右边界是 依次 尝试 2^0=1, 2^1 =2, 2^2=4, 2^3=8, O(nlogn)

每次都是尝试 start point +2^n 这样，也实现了 log(n) 的复杂度。



public class DecodeVector {

    class Pair {
        int c;
        int count;
        public Pair(int c, int count) {  
            this.c = c;
            this.count = count;
        }
    }


    public List<Pair> getCount(int[] arr) {
        List<Pair> list = new ArrayList<>();
        if (arr == null || arr.length == 0) {
            return list;
        }

        int start = 0;
        while (start < arr.length) {
            int end = findLast(start, arr);
            list.add(new Pair(arr[start], end - start + 1));
            start = end + 1;
        }

        return list;
    }


    private int findLast(int start, int[] arr) {
        int c = arr[start];
        int diff = 1;
        while (start + diff < arr.length && arr[start + diff] == c) {
            diff <<= 1;
        }
        if (start + diff >= arr.length) {
            return arr.length - 1;
        }

        int end = start + diff;
        while (start + 1 < end) {. from: 1point3acres.com/bbs 
            int mid = (end - start) / 2 + start;
            if (arr[mid] == c) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (arr[end] == c) {
            return end;
        } else {
            return start;
        }
    }


    public static void main(String[] args) {
        int[] arr = {1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3};
        DecodeVector d = new DecodeVector();
        List<Pair> res = d.getCount(arr);
        for (Pair p : res) {
            System.out.println(p.c + ": " + p.count);
        }
    }
}






46. Unique Path II，这题bug free, 很快就解出来了。
    第二题是第一题follow up. 问有2个robert, 一个在左上(A)，一个在右下(B)。
    2个机器人同时移动，A 只能移动Down, right. B 只能移动 Up,left. 写出一个方程，问A 和B能不能同时到终点(ie. A 到右下，B到左上）
    Note 1. 有障碍 2，A，B不能碰撞。 我给出了暴力的dfs解法，但是显然有更好的解法

* follow up: 
如果a,b只能一个down right, 一个up left 如果都能到的话，肯定同时，因为都走 m + n - 2 步。 
如果从a到b 只有一条道，可定相遇，没治。
有两条或以上，如果相交，肯定只相交在一点，因为他们移动方向，所以不相交在长度的中点（m+n+2）/2就行. 

两paths相交后也可能部分重合，点不在长度中见就行。 

应该相遇在 down + right = up + left
“对角线上”是down = right






47. 给一组区级的二维数组，每一组代表一个接收方，每一个接收方有一组区间。然后给一个整数，要求找出所有区间 ...

例子就是
A想要接收1~4、7~9、12~15
B想要接收2~8、10~12
C想要接收5~6

如果给一个数字8，应该返回A和B
如果给个数字5，应该返回B和C


用二分查找优化吗 还是必须build interval tree, 然后search？？？




48. Findall characters that have most continuous appearances (longest sequence). 
比如： “this send meet” -> [s, e] 再比如：“this is pea” ->[t,h,i,s,i,s,p,e,a] 这个题他只给出input和output让猜程序是干什么的。
Tricky part: 注意skip空格


第一题需要先扫一遍，统计一下连续字符个数，然后再扫，添加结果：
public static List<Character> mostContinuous(String s) {
        List<Character> list = new ArrayList<>();
        if (s == null || s.trim().isEmpty()) return list;

        s = s.trim().replaceAll(" ", "");
        int n = s.length();
        int[] dp = new int[n];
        dp[0] = 1;
        int max = 1;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i-1)) {
                dp[i] = dp[i-1] + 1;
            } else {
                dp[i] = 1;
            }
            max = Math.max(max, dp[i]);
        }

        for (int i = 0; i < dp.length; i++) {
            if (dp[i] == max) {
                list.add(s.charAt(i));
            }
        }

        return list;
    }






49. 给一个二叉树的先序遍历结果，返回中序遍历结果。讨论各种做法，复杂度。
recursive build tree and inorder traverse是o(n)的
用一个stack也可以省去Buildtree的过程了. leetcode 255 stack 解法的思想 第一个是根节点， 然后找根的右字数开始的点，根和右字数开始这中间是左子树，然后分开处理




50. 给一个字符串，如果是相邻字母是一样的话就称为一个桥，把桥之间的字符替换成加号
    --a-d*-d-a-b 变成 --a-++++-a-b




51. 把一个BST(Inplace)转化成环装结构的链表，需要首尾相接。讨论时间复杂度




52. Even Tree
even tree is a hackrank problem:
You are given a tree (a simple connected graph with no cycles). The tree has  nodes numbered from  to  and is rooted at node .
Find the maximum number of edges you can remove from the tree to get a forest such that each connected component of the forest contains an even number of vertices.




53. Find sets of values in array whose sum is equal to some number.




54. Find the subarray within an array (containing at least TWO number) which has the largest sum. 
For example, given the array [-2,-1,-3,-4,-1], the contiguous subarray [-2,-1] has the largest sum = -3. 
try to do it in O(n) time 

Followup, if input is stream, how to solve it 
public int maxSubArray(int[] nums) {}




55. A "derangement" of a sequence is a permutation where no element appears in its original position. 
For example ECABD is a derangement of ABCDE, given a string, may contain duplicate char, please out put all the derangement 
public List<char[]> getDerangement(char[]){}. 




56. Given an array of task and k wait time for which a repeated task 
needs to wait k time to execute again. please rearrange the task sequences to minimize the total time to finish all the tasks. 
Example 
Tasks = 111222, k = 2, 
One possible task sequence is 12_12_12, 
another possible task sequence is 21_21_21 
thus you shoud return 8 
public int getMiniTime(int[] nums, int k){ 
} 
follow up, output one of the sequence 12_12_12, or 21_21_21




57. Given an unsorted array, sort it in such a way that the first element is the largest value, the second element is the smallest, 
the third element is the second largest element and so on. 
[2, 4, 3, 5, 1] -> [5, 1, 4, 2, 3] 
can you do it without using extra space 
public void sortAlternate(int[] nums){}





58. Given a number of tasks (T) and servers (S), find out if the tasks can be accommodated on the servers. 
Each Task has a number of Units and each server has a number of Slots on which Units can run. 
The only condition is that two Units of the same Task "cannot" run on the same Server. 
Servers 
S[0] = "SS1", "SS2", "SS3", SS4 //Slots // 4 -> 3 -> 2 -> 1 
S[1] = "SS1", "SS2" // 2 -> 1 -> 0 -> false . visit 1point3acres.com for more.
S[2] = "SS1", "SS2", SS3, SS4, SS5 // 5 -> 4 -> 3 -> 2 
S[3] = "SS1", "SS2", SS3, SS4, SS5 // 5 -> 4 -> 3 -> 2 

Example: 
S[0] = 4 
S[1] = 3 . more info on 1point3acres.com
S[2] = 5 
S[3] = 5 
... 
Tasks 
T[0] = U0, U1, U2, U3 //Tasks 
T[1] = U0, U1 
T[2] = U0, U1, U2 
... 

Example: 
T[0] = 4 
T[1] = 2 
T[2] = 3 

implement 
boolean boolean CanRunTasks(S[], T[]){ . 1point 3acres 璁哄潧
}




59. There is a bunch of tasks, each have different time to complete, task is independent, and then there are some workers, 
How to allocate tasks to these workers to minimize the total time to complete all the task. The tasks can be randomly picked from the task list. 
Example 
Task: 2,2,3,7, 1 
Worker: 2. 
Return 8, because the first worker can work on the first three tasks : 2 + 2 + 3 = 7, and the second worker can work on the last two tasks : 
7 + 1 = 8, so the total time to finish all the task is 8. 
public int getMini(int[] tasks, int k)


We have a List of FlightRoute
public static class FlightRoute {
        String from;
        String to;
        int time;
        ....
    }
and write a function to find Shortest Path: findShorestPath(String start, String end, List<FlightRoute>routes)





60. You have a string of numbers, i.e. 123. You can insert a + or - sign in front of ever number, or you can leave it empty. Find all of the different possibilities, make the calculation and return the sum. 
For example; 
+1+2+3 = 6 
+12+3 = 15 
+123 = 123 
+1+23 = 24 
... 
-1-2-3 = 6 
... 
Return the sum of all the results.




61. Given the newest 100 entries of a person's facebook newsfeed. How would you rank the entries. 
The (for the user) most important ones should be ranked first. Which features would you use and how do you train/improve your model (machine learning)?




62. Design a algorithm to initialize the board of Candy Crush Saga. With M x N board, Q types of candies. 
(Rules: no 3 for run after initialization, must contain at least one valid move at the beginning)




63.Weighted meeting room 
Given a series of meetings, how to schedule them. Cannot attend more than a meeting at the same time. Goal is to find maximum weight subset of mutually non-overlap meetings.
class Meeting:. 1point 3acres 璁哄潧
def __init__(self):
    self.startTime
    self.endTime
    self.weight




64. Given preorder traversal [5,3,2,4,8,7,9] of a BST, how do we identify the leaf nodes without building the tree ? 




65. Given many coins of 3 different face values, print the combination sums of the coins up to 1000. Must be printed in order. 
eg: coins(10, 15, 55)
print:
10 
15 
20 
25 
30 
. 
.
1000 



66. Given an input string "aabbccba", find the shortest substring from the alphabet "abc". 
In the above example, there are these substrings "aabbc", "aabbcc", "ccba" and "cba". However the shortest substring that contains all the characters in the alphabet is "cba", so "cba" must be the output. . From 1point 3acres bbs
Output doesnt need to maintain the ordering as in the alphabet. . 1point 3acres 璁哄潧
Other examples: 
input = "abbcac", alphabet="abc" Output : shortest substring = "bca".



67. Given an Array of N elements and Integer K, write a function that returns true if the sum of any 2 elements of Array is K, false otherwise.


68. Write code to decode strings. For example, String str = "3[a2[bd]g4[ef]h]", the output should be "abdbdgefefefefhabdbdgefefefefhabdbdgefefefefh". 


69. Given an array of positive integers and a target total of X, find if there exists a contiguous subarray with sum = X 
[1, 3, 5, 18] X = 8 Output: True 
X = 9 Output: True 
X = 10 Output: False 
X = 40 Output :False





https://instant.1point3acres.com/thread/197099
http://www.1point3acres.com/bbs/thread-203983-1-1.html
http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=278686&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26sortid%3D311






*********************************
Leetcode
*********************************

5. Longest Palindromic Substring


10. Regular Expression Matching


15. 3Sum


17. Letter Combinations of a Phone Number


22. Generate Parentheses


23. Merge k sorted lists


28. Implement strStr()


29. Divide Two Integers 
  * 不用“／”，“％”运算符实现division，说了可以用binary search
  

32. Longest Valid Parentheses


33. Search in Rotated Sorted Array


37. Sudoku Solver


38. Count and Say(变形)


39. Combination Sum


42. Trapping Rain Water
407. Trapping Rain Water II


43. Multiply Strings


49. Group Anagrams - use counting sort


53. Maximum Subarray


56. Merge Intervals
Variant: 一串start time － end time，格式是Apr 2010 － Mar 2011这种，要求计算出这些时间的总跨度，重叠的跨度不重复计算。
举例：["Apr 2010 - Dec 2010", "Aug 2010 - Dec 2010", "Jan 2011 - Mar 2011"]


57. Insert Interval


62. Unique Paths I/II


65. Valid Number


71. Simplify Path


75. Sort Colors
  * 给三个funtions: is_low(), is_mid(), is_high(). 让给一个数组排序, low的放在最前面, mid的放在中间, high的放在最后面.
  * Color sort: think about when there are K colors


79. Word Search
  * 输出所有 root - leaf 的路径，递归做完了让迭代。
  * Iterative? BFS?
  
  
78. Subsets
90. Subsets II


91. Decode Ways


98. Validate Binary Search Tree


102. Binary Tree Level Order Traversal


111. Minimum Depth of Binary Tree


114. Flatten Binary Tree to Linked List
  * Linked list needs to be formed as a cycle
  

117. Populating Next Right Pointers in Each Node I / II
  * salbring tree，不过没有next指针， 你要用原来的left，right指针
  * Level BFS
  

121-123, 188, 309 Best Time to Buy and Sell Stock, (I and II)
  * buy and sell stock，每天可以买一股，也可以都卖了，或者不买不卖。Find maximum, buy from earlier days, and sell on that day.
    Given estimated stock quotes, in an array, print the maximum profit from a buy and sell. 
    i.e [19, 22, 15, 35, 40, 10, 20] would show a profit of 25(40 -15). The sale must come after the buy. Solve this in O(N) time.


125. Valid Palindrome


128. Longest Consecutive Sequence


133. Clone Graph


138. Copy List with Random Pointer


139. Word Break I/II


151. Reverse Words in a String


152. Maximum Product Subarray


158. Read N Characters Given Read4 II - Call multiple times


161. One Edit Distance


173. BST iterator
  * Iterator for a list of BSTs (heap contain each BST’s iterator)
  * BST to increasing array (Recursive, iterative)
  

191. Number of 1 Bits


198. House Robber


200. Number of Islands


206. Reverse Linked List


209. Minimum Size Subarray Sum
  * Map store previous values ( O(N) )
  * 把第一题extend到2D。给一个matrix, all elements are positive，问有没有个sub rectangle加起来和等于target。return true/false。
  * Lz听到题目有点懵，认真调整心态，解决之。先写了个cumulative sum。把所有从0,0 到i,j的和算在新的matrix的i,j上。方便之后算head到tail的sub rectangle的和。这一步O(n^2)


211. Add and Search Word (add and search word with wild card)


214. Shortest Palindrome


215. Kth Largest Element in an Array (Average O(n) Worst case O(n^2))


218. The Skyline Problem (hard)


221. Maximal square


224. Basic Calculator


238. Product of Array Except Self


239. Sliding Window Maximum


253. Meeting Rooms II (求最多interval的时间点，返回任意一个就行)


261. Graph Valid Tree (any connected graph without simple cycles is a tree).


273. Integer to English Words


277. Find the Celebrity


278. First Bad Version


282. Expression Add Operators


283. Move Zeroes - Minimizing “writes”

You are given an array of integers. Write an algorithm that brings all nonzero elements to the left of the array, and returns the number of nonzero elements. 
e.g. [1,2,0,5,3,0,4,0] => [1,2,5,3,4,0,0,0] and return 5

Note:
1. The algorithm should operate in place, i.e. shouldn't create a new array. 
2. The order of the nonzero elements does not matter. The numbers that remain in the right portion of the array can be anything. 
3. The algorithm should operate in place, i.e. shouldn't create a new array. 
4. Code should have good complexity and minimize the number of writes to the array.

Example: given the array [ 1, 0, 2, 0, 0, 3, 4 ], 
a possible answer is [ 4, 1, 3, 2, ?, ?, ? ], 4 non-zero elements, where "?" can be any number. 
2 pointers的解法为readPointer扫到非零元素的时候写到writePointer的位置，readPointer 比 writePointer快，在readPointer扫完之后writePointer在剩下的所有位置写0。





285. Inorder Successor in BST


297. Serialize and Deserialize Binary Tree


301. Remove Invalid Parentheses (hard)
Maintain counter and go from left to right, remove when necessary, then counter must be > 0, then remove “(“ from right hand side


310. Minimum Height Trees


311. Sparse Matrix Multiplication (sparse vector dot multiplication)
    这道题我当时并没有准备到，但是正因为如此，我认为我跟面试官的交流给我加分了不少。

    面试官首先问我每个vector很大，并不能在内存中存下，该怎么办，我说只需要存下非零的元素和他们的下标就行，
    然后询问面试官是否可以用预处理后的这两个vector非零元素的index和value作为输入，面试官同意后快速写完O(M*N)的代码，M和N分别是两个vector的长度。

    面试官说这两个输入如果是根据下标排序好的话应该怎么办，我说可以遍历长度较短的那一个，然后用二分搜索的方法在另一个vector中找index相同的元素，
    相乘加入到结果中，这样的话复杂度就是O(M*logN)。

    这时，面试官又问是否可以同时利用两个输入都是排序好这一个特性，我在这个地方有点卡住，但是在白板上写出一个test case，试着用可视化的方法帮助我来进行思考，
    同时面试官给了一些提醒，最后写出了O(M + N)的双指针方法

    然后问如果有一个向量比另一个长很多怎么办，遍历短的，对长的二分查找。

    两个vector相乘


314. Binary Tree Vertical Order Traversal (Print a binary tree by columns top to bottom)


334. Increasing Triplet Subsequence (一个数组内要是存在至少三个升序的数（array[x] < array[y] < array[z], x < y < z）就返回true)


341. Flatten Nested List Iterator


350. Intersection of Two Arrays II
  * Sort, then find duplicates


384. shuffle一个1 million的数组，让所有数在所有位置的概率相等


398. Random Pick Index


543. Diameter of Binary Tree


545. Boundary of Binary Tree 顺时针的print binary tree boundary, 就是从根开始，先打右边界，再打叶子，最后打左边界。

