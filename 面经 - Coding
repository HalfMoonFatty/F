** 001. BT LCA with deepest leaf
   Follow-up:
   1. Recursive and Iterative (指向母点的指针)
   2. Each node has multiple children
   * Similar to 236. Lowest Common Ancestor of a Binary Tree 
    
** 002. Prettify JSON:  输入[1,2,3, {"id": 1, "name": "wang", "tag":[1,"home",2], "price":234}]

003. Flatten Nested Array

** 004. Flatten Nested Linked List

005. Binary Tree Level Order Traversal

006. Sort color
     Follow-up: Sort K-color

007. Merge 2 array in-place

008. Balance Parentheses in a string

** 009. 给2D平面上的N个点，求离原点最近的K个点
     Given some points in two dimensional space, find k points out of all points which are nearest to origin(0,0)

010. Decode Ways 1 2
     Follow-up: Output the result of all decode string

[X] 011.  一个骑士在一个无限大的有障碍的国际象棋棋盘. calculate the shortest path to some target.
        Follow-up: how to optimize: A*, pruning.
        Edge case: how to end the program? what kinds of target is unreachable and how to avoid?

012. Longest consecutive sequence

013. Reconstruct BST From Pre-order Sequence

014. Remove Target Char from a Source String

015. Subarray Sum Equals K (4 problems)

016. Implement strStr()

017. Minimum Depth of Binary Tree

** 018. Even Tree

019. 3 Sums

020. Insert Node to Sorted LinkedList

021. Read N Characters Given Read4K / Read N Characters Given Read4K II - Call multiple times

022. Best Time to Buy and Sell Stock I-IV

023. Binary Tree print path to leaf (BT path leaf)

024. Binary Tree Vertical Order Traversal

025. Check Consecutive Subarray Duplicate Numbers

026. Remove Invalid Parentheses

** 027. Permutation in String

028. First Bad Version

029. Valid Palindrome

030. Dot Product

** 031. Find longest arithmetic subsequence in an unsorted array (Longest Arithmetic Progression)

032. longest PATH(could be the path from leaf to leaf) in binary tree(BT longest path)
     * Bianry Tree Diameter

033. Word Search I + II

034. Product of the Array

035. Combination Sum I-IV

036. Binary Tree In Order Traversal with Parent Node

037. Regular Expression Matching

[X] 038. Data Stream as Disjoint Intervals (LC 352)

039. Task Schedule 

040. Kth Largest Element in an unsorted Array  (Quick Select / Heap)

041. Reverse Print Linked List (Recursive/Iterative) / Reverse Linked List

042. Add Sum

043. Decode Password

044. Validate Binary Search Tree

** 045. Find Median of Lists

** 046. Sort Partial Sorted Array

047. Merge k Sorted Lists

** 048. Merge Interval from Sorted Arrays

049. Merge Intervals

** 050. Common Substring (找两个字符串中长度为N以上的共同子串)
    Follow-up: Longest common substring
    Follow-up: Longest common subsequnce
     
051. LCA of BST

052. LCA of BT

** 053. Add and Search Word - Data structure design

054. Minimum Window Substring

** 055. Binary Tree to Doubly LinkedList
     Follow - up: Revert double linked list back to balanced BST: 109. Convert Sorted List to Binary Search Tree

** 056. Permutations / Unique permutations

057. Binary Search Tree Iterator

058. Meeting Rooms I+II

** 059. Max Rectangle Overlap

060. Multiply Strings

061. Search in Rotated Sorted Array

062. Number of 1 Bits

** 063. Word Break 1+2

064. 2 Sum

065. Copy List with Random Pointer

066. Simplify Path

067. Excel Sheet Column Title

** 068. Find the Theif

069. Word Ladder

070. String Comparator

** 071. Contact Group

** 072. Minimum Size Subarray Sum
     # Follow-up 1: Extend to 2D and find if rectangle sum = k
     # Follow-up 2: LC363. Max Sum of Rectangle No Larger Than K

073. Clone Graph

074. Min Queue

075. Add Operator

076. Partition Array Sum

077. Symmetric Tree (recursive / iterative)

** 078. Binary Tree And Operation

** 079. Find Smallest Binary Tree Path

[X] 080. Paint House

081. Random Pick K Points in an Rectangle
     Follow up 1: LC 382. Linked List Random Node
     Follow up 2: LC 398. Random Pick Index
     Follow up 3: LC 384. Shuffle an Array

082. NextPermutation / Previous Permutation

083. Longest Palindromic Substring

084. Shortest Word Distance I-III

085. Diagonal Traverse

086. Path Between Binary Tree Nodes

087. Find Max Overlap Time

088. Remove Comments

089. Key Value Store (LRU Cache)

[X] 090. Assign Tasks to Workers

[X] 091. Island Shape

092. Array to Binary Heap Tree
     # Follow-up: addNode()

093. Find the First Column with 1

094. Is Subtree

095. Remove Duplicate Chars in a String

* 096. Find Names in Post

097. Find Least Number of Intervals from A That Can Fully Cover B

098. Find All Equivalent Pairs

099. Check Balance Parenthese

[X] 100. Find 2nd Mutal Friends
20. Recommend K friends with most mutual friends.

101. Serialize and deserialized Tree into LinkedList

102. Find the Maximum Peak or Drop

103. Sort Array of Squares

104. shortest continuous substring with all characters in input
     * 76. Minimum Window Substring
     * 30. Substring with Concatenation of All Words

105. Find all Chars with Most Continuous Appearances (longest sequence) 

106. Decode/Encode String

107. Find Char Frequency in Sorted Array

108. Maximum Subarray

109. Continuous Subarray Sum

110. BST Preorder Leaves

111. Find Common Elements in 2 Arrays

112. Print Max Depth Path of a Binary Tree

113. String Replacement

114. Target sum

115. BST Preorder to Inorder

116. Matrix Path






******************************************************************************************************************************

1. Erase duplicate in an unsorted array


2. 给定N个2D坐标（可以设想为餐厅的位置），要求输入任意坐标，可以返回方圆d距离内的所有餐厅


3. 一个完全树。node有parent指针。
每个node的值为 0或 1, 每个parent的值为两个子node的 “and” 结果
现在把一个leaf翻牌子（0变1或者1变0）把树修正一遍


4. Given an unsorted array, sort it in such a way that the first element is the largest value, the second element is the smallest, 
the third element is the second largest element and so on. 
[2, 4, 3, 5, 1] -> [5, 1, 4, 2, 3] 
can you do it without using extra space 
public void sortAlternate(int[] nums){}


5. 给一个linkedlist，里面的element都排序好了，但是是一个blackbox，有三个function可以调用。
pop()随机pop出最前面或最后面的element，
peek()随机偷看最前面或最后面的element，
isEmpty()回传linkedlist是不是空了。
问设计一个资料结构，list或是array都可以，把linkedlist里面所有的element都拿出来，并保持他们的排序。followup是如果不能用peek()该怎么做。
My thinking: if I got element A, and next element B is smaller than A, then A is from the tail of the list; 
otherwise, A is from the head of the list.


6.
第一题：binary tree，给定一个value，return bin tree里面下一个比value大的值
第二题：binary tree的node加一个ptr next，point到inorder traversal的下一个node，比上一个简单


7. find number of palindrom in a string


8. 给你一个数字比如111112222333112，返回每个数字出现的个数和数字本身，这个例子的返回为5142332112. 写完之后问这个返回的result，最短多长，最长多长。


9. Unique Path II，这题bug free, 很快就解出来了。
    第二题是第一题follow up. 问有2个robert, 一个在左上(A)，一个在右下(B)。
    2个机器人同时移动，A 只能移动Down, right. B 只能移动 Up,left. 写出一个方程，问A 和B能不能同时到终点(ie. A 到右下，B到左上）
    Note 1. 有障碍 2，A，B不能碰撞。 我给出了暴力的dfs解法，但是显然有更好的解法

* follow up: 
如果a,b只能一个down right, 一个up left 如果都能到的话，肯定同时，因为都走 m + n - 2 步。 
如果从a到b 只有一条道，可定相遇，没治。
有两条或以上，如果相交，肯定只相交在一点，因为他们移动方向，所以不相交在长度的中点（m+n+2）/2就行. 

两paths相交后也可能部分重合，点不在长度中见就行。 

应该相遇在 down + right = up + left
“对角线上”是down = right



10. Given a number of tasks (T) and servers (S), find out if the tasks can be accommodated on the servers. 
Each Task has a number of Units and each server has a number of Slots on which Units can run. 
The only condition is that two Units of the same Task "cannot" run on the same Server. 
Servers 
S[0] = "SS1", "SS2", "SS3", SS4 //Slots // 4 -> 3 -> 2 -> 1 
S[1] = "SS1", "SS2" // 2 -> 1 -> 0 -> false
S[2] = "SS1", "SS2", SS3, SS4, SS5 // 5 -> 4 -> 3 -> 2 
S[3] = "SS1", "SS2", SS3, SS4, SS5 // 5 -> 4 -> 3 -> 2 

Example: 
S[0] = 4 
S[1] = 3 
S[2] = 5 
S[3] = 5 
... 
Tasks 
T[0] = U0, U1, U2, U3 //Tasks 
T[1] = U0, U1 
T[2] = U0, U1, U2 
... 

Example: 
T[0] = 4 
T[1] = 2 
T[2] = 3 

implement 
boolean boolean CanRunTasks(S[], T[]){ 
}



11. We have a List of FlightRoute

public static class FlightRoute {
        String from;
        String to;
        int time;
        ....
    }
and write a function to find Shortest Path: findShorestPath(String start, String end, List<FlightRoute>routes)



12. Weighted meeting room 
Given a series of meetings, how to schedule them. Cannot attend more than a meeting at the same time. 
Goal is to find maximum weight subset of mutually non-overlap meetings.

class Meeting:
def __init__(self):
    self.startTime
    self.endTime
    self.weight



13. Given many coins of 3 different face values, print the combination sums of the coins up to 1000. Must be printed in order. 
eg: coins(10, 15, 55)
print:
10 
15 
20 
25 
30 
. 
.
1000 



14. 给一组区级的二维数组，每一组代表一个接收方，每一个接收方有一组区间。然后给一个整数，要求找出所有区间 ...

例子就是
A想要接收1~4、7~9、12~15
B想要接收2~8、10~12
C想要接收5~6

如果给一个数字8，应该返回A和B
如果给个数字5，应该返回B和C


用二分查找优化吗 还是必须build interval tree, 然后search？？？



15. Given an input string "aabbccba", find the shortest substring from the alphabet "abc". 
In the above example, there are these substrings "aabbc", "aabbcc", "ccba" and "cba". 
However the shortest substring that contains all the characters in the alphabet is "cba", so "cba" must be the output.
Output doesnt need to maintain the ordering as in the alphabet. 
Other examples: 
input = "abbcac", alphabet="abc" Output : shortest substring = "bca".



16. Given the newest 100 entries of a person's facebook newsfeed. How would you rank the entries. 
The (for the user) most important ones should be ranked first. Which features would you use and how do you train/improve your model (machine learning)?



17. Design a algorithm to initialize the board of Candy Crush Saga. With M x N board, Q types of candies. 
(Rules: no 3 for run after initialization, must contain at least one valid move at the beginning)



18.implement circular array
  * implement circular buffer with read & write functions


19. Check big/small endian



20. 给一个数组和一个数N，随机返回该数组中任意一个不大于N的数



21. 
输入：一个文件夹
输出：文件夹下面的所有相同文件 // MD5 hash
例如：给你一个文件夹路径，/foo/bar,要求找出这个文件夹下面的所有相同的文件，比如a和c是相同的，d和e是相同的，就输出(a,c),(d,e)

先通过dfs获取所有的文件，然后计算MD5, 然后比较是不是一样。




https://instant.1point3acres.com/thread/197099
http://www.1point3acres.com/bbs/thread-203983-1-1.html
http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=278686&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26sortid%3D311






*********************************
Leetcode
*********************************

5. Longest Palindromic Substring


10. Regular Expression Matching


15. 3Sum


17. Letter Combinations of a Phone Number


22. Generate Parentheses


23. Merge k sorted lists


28. Implement strStr()


29. Divide Two Integers 
  * 不用“／”，“％”运算符实现division，说了可以用binary search
  

32. Longest Valid Parentheses


33. Search in Rotated Sorted Array


37. Sudoku Solver


38. Count and Say(变形)


39. Combination Sum


42. Trapping Rain Water
407. Trapping Rain Water II


43. Multiply Strings


49. Group Anagrams - use counting sort


53. Maximum Subarray


56. Merge Intervals
Variant: 一串start time － end time，格式是Apr 2010 － Mar 2011这种，要求计算出这些时间的总跨度，重叠的跨度不重复计算。
举例：["Apr 2010 - Dec 2010", "Aug 2010 - Dec 2010", "Jan 2011 - Mar 2011"]


57. Insert Interval


62. Unique Paths I/II


65. Valid Number


71. Simplify Path


75. Sort Colors
  * 给三个funtions: is_low(), is_mid(), is_high(). 让给一个数组排序, low的放在最前面, mid的放在中间, high的放在最后面.
  * Color sort: think about when there are K colors


79. Word Search
  * 输出所有 root - leaf 的路径，递归做完了让迭代。
  * Iterative? BFS?
  
  
78. Subsets
90. Subsets II


91. Decode Ways


98. Validate Binary Search Tree


102. Binary Tree Level Order Traversal


111. Minimum Depth of Binary Tree


114. Flatten Binary Tree to Linked List
  * Linked list needs to be formed as a cycle
  

117. Populating Next Right Pointers in Each Node I / II
  * salbring tree，不过没有next指针， 你要用原来的left，right指针
  * Level BFS
  

121-123, 188, 309 Best Time to Buy and Sell Stock, (I and II)
  * buy and sell stock，每天可以买一股，也可以都卖了，或者不买不卖。Find maximum, buy from earlier days, and sell on that day.
    Given estimated stock quotes, in an array, print the maximum profit from a buy and sell. 
    i.e [19, 22, 15, 35, 40, 10, 20] would show a profit of 25(40 -15). The sale must come after the buy. Solve this in O(N) time.


125. Valid Palindrome


128. Longest Consecutive Sequence


133. Clone Graph


138. Copy List with Random Pointer


139. Word Break I/II


151. Reverse Words in a String


152. Maximum Product Subarray


158. Read N Characters Given Read4 II - Call multiple times


161. One Edit Distance


173. BST iterator
  * Iterator for a list of BSTs (heap contain each BST’s iterator)
  * BST to increasing array (Recursive, iterative)
  

191. Number of 1 Bits


198. House Robber


200. Number of Islands


206. Reverse Linked List


209. Minimum Size Subarray Sum
  * Map store previous values ( O(N) )
  * 把第一题extend到2D。给一个matrix, all elements are positive，问有没有个sub rectangle加起来和等于target。return true/false。
  * Lz听到题目有点懵，认真调整心态，解决之。先写了个cumulative sum。把所有从0,0 到i,j的和算在新的matrix的i,j上。方便之后算head到tail的sub rectangle的和。这一步O(n^2)


211. Add and Search Word (add and search word with wild card)


214. Shortest Palindrome


215. Kth Largest Element in an Array (Average O(n) Worst case O(n^2))


218. The Skyline Problem (hard)


221. Maximal square


224. Basic Calculator


238. Product of Array Except Self


239. Sliding Window Maximum


253. Meeting Rooms II (求最多interval的时间点，返回任意一个就行)


261. Graph Valid Tree (any connected graph without simple cycles is a tree).


273. Integer to English Words


277. Find the Celebrity


278. First Bad Version


282. Expression Add Operators


283. Move Zeroes - Minimizing “writes”

You are given an array of integers. Write an algorithm that brings all nonzero elements to the left of the array, and returns the number of nonzero elements. 
e.g. [1,2,0,5,3,0,4,0] => [1,2,5,3,4,0,0,0] and return 5

Note:
1. The algorithm should operate in place, i.e. shouldn't create a new array. 
2. The order of the nonzero elements does not matter. The numbers that remain in the right portion of the array can be anything. 
3. The algorithm should operate in place, i.e. shouldn't create a new array. 
4. Code should have good complexity and minimize the number of writes to the array.

Example: given the array [ 1, 0, 2, 0, 0, 3, 4 ], 
a possible answer is [ 4, 1, 3, 2, ?, ?, ? ], 4 non-zero elements, where "?" can be any number. 
2 pointers的解法为readPointer扫到非零元素的时候写到writePointer的位置，readPointer 比 writePointer快，在readPointer扫完之后writePointer在剩下的所有位置写0。





285. Inorder Successor in BST


297. Serialize and Deserialize Binary Tree


301. Remove Invalid Parentheses (hard)
Maintain counter and go from left to right, remove when necessary, then counter must be > 0, then remove “(“ from right hand side


310. Minimum Height Trees


311. Sparse Matrix Multiplication (sparse vector dot multiplication)
    这道题我当时并没有准备到，但是正因为如此，我认为我跟面试官的交流给我加分了不少。

    面试官首先问我每个vector很大，并不能在内存中存下，该怎么办，我说只需要存下非零的元素和他们的下标就行，
    然后询问面试官是否可以用预处理后的这两个vector非零元素的index和value作为输入，面试官同意后快速写完O(M*N)的代码，M和N分别是两个vector的长度。

    面试官说这两个输入如果是根据下标排序好的话应该怎么办，我说可以遍历长度较短的那一个，然后用二分搜索的方法在另一个vector中找index相同的元素，
    相乘加入到结果中，这样的话复杂度就是O(M*logN)。

    这时，面试官又问是否可以同时利用两个输入都是排序好这一个特性，我在这个地方有点卡住，但是在白板上写出一个test case，试着用可视化的方法帮助我来进行思考，
    同时面试官给了一些提醒，最后写出了O(M + N)的双指针方法

    然后问如果有一个向量比另一个长很多怎么办，遍历短的，对长的二分查找。

    两个vector相乘


314. Binary Tree Vertical Order Traversal (Print a binary tree by columns top to bottom)


334. Increasing Triplet Subsequence (一个数组内要是存在至少三个升序的数（array[x] < array[y] < array[z], x < y < z）就返回true)


341. Flatten Nested List Iterator


350. Intersection of Two Arrays II
  * Sort, then find duplicates


384. shuffle一个1 million的数组，让所有数在所有位置的概率相等


398. Random Pick Index


543. Diameter of Binary Tree


545. Boundary of Binary Tree 顺时针的print binary tree boundary, 就是从根开始，先打右边界，再打叶子，最后打左边界。

